using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GodotVcs.Gen;

[Generator(LanguageNames.CSharp)]
public class ComponentGen : IIncrementalGenerator
{
    public const string ComponentAttributeName = "GodotVcs.Lib.ComponentAttribute";
    public const string CompPropAttributeName = "GodotVcs.Lib.CompPropAttribute";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var compClasses = context.SyntaxProvider.ForAttributeWithMetadataName(
            ComponentAttributeName,
            static (node, _) => node is ClassDeclarationSyntax,
            static (ctx, _) =>
            {
                var symbol = ctx.TargetSymbol as INamedTypeSymbol;
                if (symbol is not { TypeKind: TypeKind.Class })
                    return null;

                // 获取类中带有 CompProp 特性的 public 属性
                var properties = symbol.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(prop => prop.DeclaredAccessibility == Accessibility.Public &&
                                   prop.GetAttributes().Any(attr =>
                                       attr.AttributeClass?.Name == "CompPropAttribute" ||
                                       attr.AttributeClass?.ToDisplayString() == CompPropAttributeName))
                    .Select(prop =>
                    {
                        // 获取 CompProp 特性的 Value
                        var CompPropAttr = prop.GetAttributes()
                            .FirstOrDefault(attr =>
                                attr.AttributeClass?.Name == "CompPropAttribute" ||
                                attr.AttributeClass?.ToDisplayString() == CompPropAttributeName);
                        
                        var initValue = CompPropAttr?.ConstructorArguments.FirstOrDefault().Value;
                        
                        return new PropertyInfo
                        {
                            Name = prop.Name,
                            Type = prop.Type,
                            InitValue = initValue
                        };
                    })
                    .ToImmutableArray();

                if (properties.IsEmpty)
                    return null;

                return new ClassInfo
                {
                    Symbol = symbol,
                    Properties = properties,
                    SyntaxNode = ctx.TargetNode as ClassDeclarationSyntax
                };
            });

        var compilationAndClasses = context.CompilationProvider.Combine(
            compClasses.Where(static info => info != null).Collect());

        context.RegisterSourceOutput(
            compilationAndClasses,
            static (spc, source) => Execute(source.Right, spc));
    }

    private static void Execute(ImmutableArray<ClassInfo?> classes,
        SourceProductionContext context)
    {
        foreach (var classInfo in classes)
        {
            if (classInfo == null || classInfo.Symbol == null)
                continue;

            try
            {
                var source = GenerateClass(classInfo);
                var fileName = $"{classInfo.Symbol.Name}.g.cs";
                context.AddSource(fileName, source);
            }
            catch (Exception ex)
            {
                // 报告生成错误
                var diagnostic = Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "GODOTVCSGEN001",
                        "Component code generation failed",
                        "Failed to generate code for {0}: {1}",
                        "CodeGeneration",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    classInfo.SyntaxNode?.GetLocation(),
                    classInfo.Symbol.Name,
                    ex.Message);
                context.ReportDiagnostic(diagnostic);
            }
        }
    }

    private static string GenerateClass(ClassInfo classInfo)
    {
        var symbol = classInfo.Symbol;
        var sb = new StringBuilder();
        
        // 添加文件头
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // 收集需要的 using 语句
        var requiredUsings = new HashSet<string>
        {
            "System" // 用于 Action<T> 事件
        };

        // 获取类的命名空间
        var namespaceName = symbol?.ContainingNamespace.ToDisplayString();
        if (!string.IsNullOrEmpty(namespaceName))
        {
            // 如果类在命名空间中，添加命名空间 using
            // 但通常不需要，因为生成的代码在同一个命名空间
        }

        // 添加 using 语句
        foreach (var usingName in requiredUsings.OrderBy(u => u))
        {
            sb.AppendLine($"using {usingName};");
        }
        
        sb.AppendLine();

        // 添加命名空间（如果有）
        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        // 添加类声明
        if (symbol != null)
        {
            var accessibility = GetAccessibilityKeyword(symbol.DeclaredAccessibility);
            sb.AppendLine($"{accessibility} partial class {symbol.Name}");
        }

        sb.AppendLine("{");

        // 为每个属性生成代码
        foreach (var prop in classInfo.Properties)
        {
            GeneratePropertyCode(sb, prop);
        }

        sb.AppendLine("}");
        
        return sb.ToString();
    }

    private static void GeneratePropertyCode(StringBuilder sb, PropertyInfo prop)
    {
        var propName = prop.Name;
        var fieldName = $"_{char.ToLowerInvariant(propName[0])}{propName.Substring(1)}";
        var typeName = GetTypeDisplayString(prop.Type);

        // 生成私有字段
        var initValue = FormatInitValue(prop.InitValue, prop.Type);
        sb.AppendLine($"    private {typeName} {fieldName}{(initValue != null ? $" = {initValue}" : "")};");
        sb.AppendLine();

        // 生成 Get 方法
        sb.AppendLine($"    public {typeName} Get{propName}() => {fieldName};");
        sb.AppendLine();

        // 生成 Set 方法
        sb.AppendLine($"    public void Set{propName}({typeName} value)");
        sb.AppendLine("    {");
        sb.AppendLine($"        {propName}Changing?.Invoke(value);");
        sb.AppendLine($"        if (Equals(value, {fieldName})) return;");
        sb.AppendLine($"        {fieldName} = value;");
        sb.AppendLine($"        {propName}Changed?.Invoke(value);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // 生成 Changing 事件
        sb.AppendLine($"    public event Action<{typeName}>? {propName}Changing;");
        sb.AppendLine();

        // 生成 Changed 事件
        sb.AppendLine($"    public event Action<{typeName}>? {propName}Changed;");
        sb.AppendLine();
    }

    private static string GetTypeDisplayString(ITypeSymbol typeSymbol)
    {
        // 使用 ToDisplayString 获取类型名称，使用简短格式
        return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
            .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)
            .WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.UseSpecialTypes));
    }

    private static string? FormatInitValue(object? value, ITypeSymbol typeSymbol)
    {
        if (value != null)
            return value switch
            {
                string str => $"\"{str.Replace("\"", "\\\"")}\"",
                char c => $"'{c}'",
                bool b => b ? "true" : "false",
                // 数值类型
                sbyte or byte or short or ushort or int or uint or long or ulong or float or double or decimal => value
                    switch
                    {
                        // 处理浮点数后缀
                        float f => $"{f}f",
                        double d => d.ToString(CultureInfo.InvariantCulture),
                        decimal m => $"{m}m",
                        _ => value.ToString()
                    },
                _ => value.ToString()
            };
        // 检查类型是否可空
        if (typeSymbol.IsReferenceType || 
            typeSymbol is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T })
        {
            return "null";
        }
        return null;

    }

    private static string GetAccessibilityKeyword(Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => "public"
        };
    }

    private class ClassInfo
    {
        public INamedTypeSymbol? Symbol { get; set; }
        public ImmutableArray<PropertyInfo> Properties { get; set; }
        public ClassDeclarationSyntax? SyntaxNode { get; set; }
    }

    private class PropertyInfo
    {
        public string Name { get; set; } = string.Empty;
        public ITypeSymbol Type { get; set; } = null!;
        public object? InitValue { get; set; }
    }
}